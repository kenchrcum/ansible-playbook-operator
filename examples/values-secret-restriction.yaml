# Secret Access Restriction Configuration Examples
# This file demonstrates how to configure Secret access restrictions using resourceNames

# =============================================================================
# EXAMPLE 1: DISABLED (Default Behavior)
# =============================================================================
# Operator can access all Secrets in the namespace

rbac:
  preset: minimal
  secretRestriction:
    enabled: false
    allowedSecrets: []
    crossNamespaceSecrets: {}

# Generated Permissions:
# - apiGroups: [""]
#   resources: ["secrets"]
#   verbs: ["get", "list", "watch"]
#
# Security Level: MEDIUM (can access any Secret in namespace)
# Use Cases: Development, testing, when Secret names are dynamic
# Limitations: Broad Secret access within namespace

# =============================================================================
# EXAMPLE 2: ENABLED WITH STATIC SECRET LIST
# =============================================================================
# Operator can only access explicitly listed Secrets

rbac:
  preset: minimal
  secretRestriction:
    enabled: true
    allowedSecrets:
      - github-token
      - ssh-key
      - vault-password
      - db-credentials
      - aws-credentials
    crossNamespaceSecrets: {}

# Generated Permissions:
# - apiGroups: [""]
#   resources: ["secrets"]
#   verbs: ["get", "list", "watch"]
#   resourceNames:
#     - github-token
#     - ssh-key
#     - vault-password
#     - db-credentials
#     - aws-credentials
#
# Security Level: HIGH (only listed Secrets accessible)
# Use Cases: Production environments with known Secret names
# Limitations: Requires manual updates when new Secrets are referenced

# =============================================================================
# EXAMPLE 3: CROSS-NAMESPACE SECRET ACCESS (SCOPED PRESET)
# =============================================================================
# Operator can access Secrets across multiple namespaces with restrictions

operator:
  watch:
    scope: all

rbac:
  preset: scoped
  secretRestriction:
    enabled: true
    allowedSecrets:
      - shared-github-token
      - shared-ssh-key
    crossNamespaceSecrets:
      production:
        - prod-db-credentials
        - prod-aws-credentials
      staging:
        - staging-db-credentials
        - staging-aws-credentials
      shared:
        - shared-vault-password

# Generated Permissions:
# - ClusterRole: Read access to CRDs, namespaces, secrets, configmaps
# - RoleBinding per namespace: Access to specific Secrets in each namespace
#
# Security Level: HIGH (cross-namespace but restricted)
# Use Cases: Multi-tenant environments with shared Secrets
# Limitations: Complex configuration, requires separate RoleBindings per namespace

# =============================================================================
# EXAMPLE 4: PRODUCTION SECURITY-FOCUSED CONFIGURATION
# =============================================================================
# Maximum security with minimal Secret access

rbac:
  preset: minimal
  secretRestriction:
    enabled: true
    allowedSecrets:
      # Repository authentication
      - github-token
      - gitlab-token
      - ssh-key
      # Application secrets
      - vault-password
      - db-credentials
      - redis-credentials
      # Cloud provider credentials
      - aws-credentials
      - azure-credentials
      - gcp-credentials
    crossNamespaceSecrets: {}

# Security Level: MAXIMUM (only explicitly allowed Secrets)
# Use Cases: High-security environments, compliance requirements
# Limitations: High operational overhead, requires careful planning

# =============================================================================
# OPERATIONAL CONSIDERATIONS
# =============================================================================

# 1. Secret Discovery
#    - Before enabling restriction, audit all CRDs to identify referenced Secrets
#    - Use kubectl to find all secretRef references:
#      kubectl get repositories,playbooks,schedules -o yaml | grep -A5 secretRef

# 2. Maintenance Overhead
#    - New Secrets require Helm chart updates and redeployment
#    - Consider using a GitOps workflow to manage Secret allowlists
#    - Document all Secret dependencies in your infrastructure code

# 3. Error Handling
#    - Monitor operator logs for "forbidden" errors when accessing Secrets
#    - Set up alerts for Secret access failures
#    - Have a rollback plan to disable restriction if needed

# 4. Testing Strategy
#    - Test Secret restriction in staging environment first
#    - Validate all playbooks can access required Secrets
#    - Test Secret rotation procedures with restrictions enabled

# =============================================================================
# MIGRATION GUIDE
# =============================================================================

# Step 1: Audit Current Secret Usage
# kubectl get repositories,playbooks,schedules -o yaml | grep -A5 secretRef

# Step 2: Create Initial Allowlist
# rbac:
#   secretRestriction:
#     enabled: true
#     allowedSecrets:
#       - secret1
#       - secret2
#       # Add all discovered Secrets

# Step 3: Deploy and Test
# helm upgrade ansible-playbook-operator ./helm/ansible-playbook-operator \
#   --values values-secret-restriction.yaml

# Step 4: Monitor and Iterate
# - Watch operator logs for permission errors
# - Add missing Secrets to allowlist as needed
# - Remove unused Secrets from allowlist

# =============================================================================
# TROUBLESHOOTING
# =============================================================================

# Common Issues:

# 1. "forbidden: User cannot get resource 'secrets'"
#    Solution: Add missing Secret to allowedSecrets list

# 2. "forbidden: User cannot list resource 'secrets'"
#    Solution: Ensure secretRestriction.enabled is true and allowedSecrets is populated

# 3. Cross-namespace Secret access fails
#    Solution: Configure crossNamespaceSecrets mapping for scoped/cluster-admin presets

# Debug Commands:
# kubectl auth can-i get secrets --as=system:serviceaccount:default:ansible-playbook-operator
# kubectl get role ansible-playbook-operator -o yaml
# kubectl logs -l app.kubernetes.io/name=ansible-playbook-operator

# =============================================================================
# SECURITY BEST PRACTICES
# =============================================================================

# 1. Principle of Least Privilege
#    - Only include Secrets that are actually referenced by CRDs
#    - Regularly audit and remove unused Secrets from allowlist
#    - Use separate Secrets for different environments

# 2. Secret Lifecycle Management
#    - Rotate Secrets regularly
#    - Use external secret management systems when possible
#    - Monitor Secret access patterns

# 3. Documentation and Compliance
#    - Document all Secret dependencies
#    - Maintain audit trails of Secret access
#    - Follow organizational security policies

# 4. Monitoring and Alerting
#    - Set up alerts for Secret access failures
#    - Monitor for unusual Secret access patterns
#    - Track Secret usage metrics
